<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Item Glossary Viewer</title>
			<link rel="stylesheet" href="style.css?v=3.9">

			<!-- moved all theme styles to style.css -->

</head>
<body>
	<h1>Item Glossary Viewer</h1>
	<div class="top-bar"><button id="themeToggle" class="theme-toggle">Light Mode</button></div>
	<div id="controls">
		<input id="q" type="search" placeholder="Search: effect, name, region (e.g. R01), source (e.g. Purchase). Comma-separated. Use -term to exclude by region/source or -event to exclude events; use event to include only events; use &lt;region to search up to region." autocomplete="off" />
		<span id="status" class="muted">Loading item_glossary.jsonâ€¦</span>
		<label id="fallback" class="muted">or open file: <input id="fileInput" type="file" accept="application/json,.json" /></label>
		<label id="constantsFallback" class="muted" style="display:none">or open constants: <input id="constantsFileInput" type="file" accept="application/json,.json" /></label>
	</div>
	<div id="equippedControls" style="display:none">
		<input id="equippedSearch" type="search" placeholder="Search equipped effects..." autocomplete="off" style="flex: 1 1 420px; padding: 8px 10px; font-size: 14px;" />
	</div>
	<div class="tabs">
		<div id="tabBrowse" class="tab active">Browse</div>
		<div id="tabEquipped" class="tab">Equipped <span id="eqCount" class="badge">0</span></div>
		<div class="toggles">
			<label><input type="checkbox" id="toggleAcc3" checked /> 3rd acc.</label>
			<label><input type="checkbox" id="toggleRet3" checked /> 3rd ret.</label>
			<label><input type="checkbox" id="toggleCategorize" /> Categorize</label>
		</div>
	</div>
	<div id="browseView">
		<div id="categoryTabs" style="display:none">
			<div class="category-tabs"></div>
		</div>
		<div id="results"></div>
	</div>
	<div id="equippedView" style="display:none">
		<div id="equippedCategoryTabs" style="display:none">
			<div class="category-tabs"></div>
		</div>
		<div style="margin-bottom:10px" class="controls-inline">
			<button id="clearAll" class="btn">Clear all</button>
			<button id="toggleEqVis" class="btn">Show equipped items</button>
			<button id="saveBuild" class="btn">Save current build</button>
			<span class="muted">Click item to equip/unequip. Use remove buttons to unequip from list.</span>
		</div>
		<div class="section">
			<h2 id="savedBuildsHeader" style="color: #B9DAA7;">Saved Builds</h2>
			<div id="savedBuilds" class="saved-builds"></div>
		</div>
		<div id="missingTypes" style="display:none" class="missing-banner"></div>
		<div id="equippedLists" data-hidden="1" style="display:none"></div>
		<div class="section">
			<h2 id="aggEffectsHeader" style="color: #91CDBE;">Aggregated Effects</h2>
			<div id="aggEffects"></div>
		</div>
	</div>
	<div id="toast" style="display:none"><span class="msg"></span></div>
	<div id="helpBtn" class="help-btn">?</div>
	<div id="helpPanel" class="help-panel" style="display:none">
		<button class="btn help-close" id="helpClose">Close</button>
		<h3>Search rules</h3>
		<ul>
			<li>Check the "Categorize" box to see items grouped by type.</li>
			<li>Comma-separated terms (ALL have to be satisfied); effect, name, region or source : e.g., R07, drop, lifebane.</li>
			<li>Prefix with '!' to search by type: e.g. !weapon, !retainer, !accessory (has to be full type name, not just a part of it).</li>
			<li>Prefix with '-' to exclude by region/source/event (AT LEAST ONE has to be satisfied): e.g., -R01.3, -purch, -event.</li>
			<li>Prefix with '&lt;' to search only up to a specific region (only applies to non-event regions).</li>
			<li>Use 'event' to include only event regions (like R01.3, RAA). Use '-event' to exclude event regions.</li>
			<li>Multiple effects allowed; results sorted by the first effect term's numeric value (then second, etc.).</li>
			<li>Negative values for any searched effect are highlighted red (Temperance excluded).</li>
			<li>Examples: "blood cr, summ, -R01.3, -purch"; "event, lifebane"; "R04, Purchase, Blood Craze"</li>
			<li>Clicking on the "Wiki" link leads you to the Bloodlore Chronicles wiki page for the item.</li>
		</ul>
		<h3>Equip rules</h3>
		<ul>
			<li>Click on an item to equip it. Click again to unequip. (Don't forget to equip all of your collections!)</li>
			<li>Check the "3rd acc." and/or "3rd ret." boxes to allow 3rd slots of accessory and/or retainer.</li>
			<li>Show/hide equipped items with the button on top.</li>
			<li>When equipped items are shown, it says what equipped items are missing.</li>
			<li>Save your loadout using the "Save current build" button.</li>
			<li>Delete a saved loadout with the "X" button.</li>
			<li>Aggregated stats are ordered alphabetically except for health, weapon damage and retainer weapon damage always being on top.</li>
		</ul>
	</div>

	<script>
	(function(){
		const ORDERED_TYPES = [
			'weapon','head','chest','hand','feet','mount','accessory','retainer','coffin','power','emblem','collection','achievement','hex','bait','coin'
		];
		const CACHE_KEY = 'itemGlossaryJsonTextV1';
		const CONSTANTS_CACHE_KEY = 'constantsJsonTextV1';
		const BUILDS_KEY = 'itemGlossarySavedBuildsV1';
		const SETTINGS_KEY = 'itemGlossarySettingsV1';
        const THEME_KEY = 'itemGlossaryThemeV1';
		let allowAccThird = true;
		let allowRetThird = true;
		let categorizeMode = false;
		let currentCategory = 'all';
		let skill_groups = {};
		let combineable = [];
		let type_map = {};
		let browseSearchText = '';
		let equippedSearchText = '';

		function loadSettings() {
			try {
				const settings = localStorage.getItem(SETTINGS_KEY);
				if (settings) {
					const parsed = JSON.parse(settings);
					allowAccThird = parsed.allowAccThird !== undefined ? parsed.allowAccThird : true;
					allowRetThird = parsed.allowRetThird !== undefined ? parsed.allowRetThird : true;
					categorizeMode = parsed.categorizeMode !== undefined ? parsed.categorizeMode : false;
					
					// Update checkbox states
					document.getElementById('toggleAcc3').checked = allowAccThird;
					document.getElementById('toggleRet3').checked = allowRetThird;
					document.getElementById('toggleCategorize').checked = categorizeMode;
					
					// Apply categorize mode if it was saved as true
					if (categorizeMode) {
						const categoryTabs = document.getElementById('categoryTabs');
						const equippedCategoryTabs = document.getElementById('equippedCategoryTabs');
						categoryTabs.style.display = 'block';
						equippedCategoryTabs.style.display = 'block';
					}
				}
			} catch (error) {
				console.error('Failed to load settings:', error);
			}

            // Load saved theme before wiring events
            try {
                const savedTheme = localStorage.getItem(THEME_KEY);
                if (savedTheme === 'light' || savedTheme === 'dark') {
                    document.documentElement.setAttribute('data-theme', savedTheme);
                } else {
                    document.documentElement.removeAttribute('data-theme');
                }
            } catch (e) {}
		}

		function saveSettings() {
			try {
				const settings = {
					allowAccThird,
					allowRetThird,
					categorizeMode
				};
				localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
			} catch (error) {
				console.error('Failed to save settings:', error);
			}
		}

		async function loadConstants() {
			try {
				const cached = localStorage.getItem(CONSTANTS_CACHE_KEY);
				if (cached) {
					const constants = JSON.parse(cached);
					skill_groups = constants.skill_groups;
					combineable = constants.combineable;
					type_map = constants.type_map;
					renderAggregatedEffects();
					return;
				}
			} catch (cacheError) {
				console.error('Failed to load constants from cache:', cacheError);
			}
			
			try {
				const response = await fetch('constants.json?v=' + Date.now(), { cache: 'no-store' });
				if (!response.ok) throw new Error('HTTP ' + response.status);
				const text = await response.text();
				localStorage.setItem(CONSTANTS_CACHE_KEY, text);
				const constants = JSON.parse(text);
				skill_groups = constants.skill_groups;
				combineable = constants.combineable;
				type_map = constants.type_map;
				renderAggregatedEffects();
				return;
			} catch (error) {
				console.error('Failed to load constants.json:', error);
			}
			
			document.getElementById('constantsFallback').style.display = 'inline';
		}

		function normalizeType(raw) {
			if (!raw) return '';
			const s = String(raw).trim().toLowerCase();
			return type_map[s] || s;
		}

		function normalizeKey(k){ return String(k||'').toLowerCase(); }
		function includesEffectKey(effects, query){
			if (!effects) return false;
			const q = normalizeKey(query);
			for (const key of Object.keys(effects)){
				if (normalizeKey(key).includes(q)) return true;
			}
			return false;
		}
		function includesRegion(region, query){
			if (!region) return false;
			return normalizeKey(region).includes(normalizeKey(query));
		}
		function includesSource(source, query){
			if (!source) return false;
			const q = normalizeKey(query);
			if (Array.isArray(source)) return source.some(s => normalizeKey(s).includes(q));
			return normalizeKey(source).includes(q);
		}
		function includesName(name, query){
			if (!name) return false;
			return normalizeKey(name).includes(normalizeKey(query));
		}
		function formatSource(source){
			if (!source) return '';
			if (Array.isArray(source)) return source.join(', ');
			return String(source);
		}
		function maxNumericFromValue(value){
			if (value == null) return 0;
			if (Array.isArray(value)){
				let m = 0;
				for (const v of value) m = Math.max(m, maxNumericFromValue(v));
				return m;
			}
			let s = String(value).replace(/,/g,'.');
			const arr = [];
			const rangeRe = /([+-]?\d+(?:\.\d+)?)\s*-\s*([+-]?\d+(?:\.\d+)?)/g;
			let copy = s;
			let rm;
			while ((rm = rangeRe.exec(s))){
				arr.push(parseFloat(rm[1]), parseFloat(rm[2]));
				copy = copy.replace(rm[0], ' ');
			}
			const numMatches = copy.match(/[+-]?\d+(?:\.\d+)?/g);
			if (numMatches) for (const n of numMatches) arr.push(parseFloat(n));
			const nums = arr.filter(n => !Number.isNaN(n));
			if (nums.length === 0) return 0;
			return Math.max(...nums);
		}
		function minNumericFromValue(value){
			if (value == null) return 0;
			if (Array.isArray(value)){
				let m = Infinity;
				let seen = false;
				for (const v of value) {
					const mn = minNumericFromValue(v);
					if (!Number.isNaN(mn)) {
						m = Math.min(m, mn);
						seen = true;
					}
				}
				return seen ? m : 0;
			}
			let s = String(value).replace(/,/g,'.');
			const arr = [];
			const rangeRe = /([+-]?\d+(?:\.\d+)?)\s*-\s*([+-]?\d+(?:\.\d+)?)/g;
			let copy = s;
			let rm;
			while ((rm = rangeRe.exec(s))) {
				arr.push(parseFloat(rm[1]), parseFloat(rm[2]));
				copy = copy.replace(rm[0], ' ');
			}
			const numMatches = copy.match(/[+-]?\d+(?:\.\d+)?/g);
			if (numMatches) for (const n of numMatches) arr.push(parseFloat(n));
			const nums = arr.filter(n => !Number.isNaN(n));
			if (nums.length === 0) return 0;
			return Math.min(...nums);
		}
		function rangeFromValue(value){
			if (value == null) return {min:0, max:0};
			if (Array.isArray(value)){
				return value.map(rangeFromValue).reduce((acc,r)=>({min:acc.min+r.min, max:acc.max+r.max}), {min:0,max:0});
			}
			let s = String(value).replace(/,/g,'.');
			let minSum = 0, maxSum = 0;
			const rangeRe = /([+-]?\d+(?:\.\d+)?)\s*-\s*([+-]?\d+(?:\.\d+)?)/g;
			let rm;
			while ((rm = rangeRe.exec(s))){
				minSum += parseFloat(rm[1]);
				maxSum += parseFloat(rm[2]);
				s = s.replace(rm[0], ' ');
			}
			const singles = s.match(/[+-]?\d+(?:\.\d+)?/g);
			if (singles){
				for (const n of singles) {
					const v = parseFloat(n);
					minSum += v;
					maxSum += v;
				}
			}
			return {min:minSum, max:maxSum};
		}
		function sanitizeEffectValue(key, val){
			const k = normalizeKey(key);
			function cleanOne(v){
				let out = String(v);
				if (k.includes('timewalker')) out = out.replace(/\s*-s\s*$/i, '');
				if (k.includes('coolness')) out = out.replace(/\s*!+\s*$/i, '');
				if (k.includes('health')) out = out.replace(/\+\s*$/i, '');
				return out;
			}
			if (Array.isArray(val)) return val.map(cleanOne);
			return cleanOne(val);
		}
		function collectEffectDisplayAll(effects, effectTokens){
			if (!effects || Object.keys(effects).length === 0) return '';
			const tokens = (effectTokens||[]).map(normalizeKey);
			const matchedByToken = tokens.map(()=>[]);
			const matchedOther = [];
			const others = [];
			for (const [key,rawVal] of Object.entries(effects||{})){
				const val = sanitizeEffectValue(key, rawVal);
				const valueStr = Array.isArray(val) ? val.join(', ') : String(val);
				const line = `${key}: ${valueStr}`;
				const k = normalizeKey(key);
				let placed=false;
				for (let i=0;i<tokens.length;i++){
					if (k.includes(tokens[i])){ matchedByToken[i].push(line); placed=true; break; }
				}
				if (!placed){
					if (tokens.length>0 && k.includes(tokens[0])) matchedOther.push(line); else others.push(line);
				}
			}
			
			// Only apply priority sorting when no search tokens (same as aggregated stats order)
			if (tokens.length === 0) {
				function effectSortPriority(line) {
					const key = line.split(':')[0].toLowerCase();
					if (key.includes('health')) return 0;
					if (key.includes('weapon') && key.includes('damage') && !key.includes('retainer')) return 1;
					if (key.includes('retainer') && key.includes('weapon') && key.includes('damage')) return 2;
					return 3;
				}
				
				const allEffects = matchedByToken.flat().concat(matchedOther).concat(others);
				allEffects.sort((a, b) => {
					const pa = effectSortPriority(a);
					const pb = effectSortPriority(b);
					if (pa !== pb) return pa - pb;
					return a.localeCompare(b);
				});
				
				return allEffects.join(' | ');
			} else {
				// When searching, use the same order as normal search mode
				return matchedByToken.flat().concat(matchedOther).concat(others).join(' | ');
			}
		}
		function maxNumericAcrossMatched(effects, effectQuery){
			if (!effectQuery) return 0;
			const q = normalizeKey(effectQuery);
			let best = -Infinity;
			let found = false;
			for (const [key,val] of Object.entries(effects||{})){
				if (normalizeKey(key).includes(q)){
					found = true;
					best = Math.max(best, maxNumericFromValue(val));
				}
			}
			return found ? best : 0;
		}
		function minNumericAcrossMatched(effects, effectQuery){
			if (!effectQuery) return 0;
			const q = normalizeKey(effectQuery);
			let worst = Infinity;
			let found = false;
			for (const [key,val] of Object.entries(effects||{})){
				if (normalizeKey(key).includes(q)){
					found = true;
					worst = Math.min(worst, minNumericFromValue(val));
				}
			}
			return found ? worst : 0;
		}
		function anyNegativeForEffects(effects, effectTokens){
			for (const tok of effectTokens||[]){
				let hasTemp = false;
				for (const k of Object.keys(effects||{})) {
					if (normalizeKey(k).includes('temperance') && normalizeKey(k).includes(tok)) {
						hasTemp = true;
						break;
					}
				}
				if (hasTemp) continue;
				const mn = minNumericAcrossMatched(effects, tok);
				if (mn < 0) return true;
			}
			return false;
		}

		function isEventRegion(region){
			const s = String(region||'').toUpperCase();
			if (!s.startsWith('R')) return false;
			return !/^R\d+$/.test(s);
		}

		function compareRegions(region1, region2) {
			// Convert to uppercase for comparison
			const r1 = String(region1 || '').toUpperCase();
			const r2 = String(region2 || '').toUpperCase();
			
			// If both are regular regions (R01, R02, etc.), compare numerically
			if (/^R\d+$/.test(r1) && /^R\d+$/.test(r2)) {
				const num1 = parseInt(r1.substring(1));
				const num2 = parseInt(r2.substring(1));
				return num1 - num2;
			}
			
			// If one is regular and one is not, regular regions come first
			const isRegular1 = /^R\d+$/.test(r1);
			const isRegular2 = /^R\d+$/.test(r2);
			
			if (isRegular1 && !isRegular2) return -1;
			if (!isRegular1 && isRegular2) return 1;
			
			// For non-regular regions, use string comparison
			return r1.localeCompare(r2);
		}

		function isRegionLessThan(itemRegion, maxRegion) {
			// Event regions and special regions (PS2024, PS2025, etc.) are always included
			if (isEventRegion(itemRegion)) return true;
			if (!itemRegion.toUpperCase().startsWith('R')) return true;
			
			// For regular regions, compare numerically
			return compareRegions(itemRegion, maxRegion) <= 0;
		}

		function flatten(data){
			const items = [];
			for (const region of Object.keys(data||{})){
				const regionObj = data[region] || {};
				for (const typeKey of Object.keys(regionObj)){
					const typeObj = regionObj[typeKey] || {};
					for (const name of Object.keys(typeObj)){
						const item = typeObj[name] || {};
						const tags = [];
						if (isEventRegion(region)) tags.push('event');
						items.push({ region, rawType: typeKey, type: normalizeType(typeKey), name, effects: item.effects || {}, source: item.source, tags });
					}
				}
			}
			return items;
		}

		function groupByTypeOrdered(items){
			const groups = new Map();
			for (const t of ORDERED_TYPES) groups.set(t, []);
			for (const it of items){
				const key = groups.has(it.type) ? it.type : it.rawType.toLowerCase();
				if (!groups.has(key)) groups.set(key, []);
				groups.get(key).push(it);
			}
			return groups;
		}

		function parseQuery(q){
			const raw = q.split(',').map(s => s.trim()).filter(Boolean);
			const pos = [], neg = [], types = [], lessThanRegions = [];
			for (const r of raw){
				if (r.startsWith('-')) neg.push(normalizeKey(r.slice(1)));
				else if (r.startsWith('!')) types.push(normalizeType(r.slice(1)));
				else if (r.startsWith('<')) {
					const region = r.slice(1).trim();
					if (region) lessThanRegions.push(normalizeKey(region));
				}
				else pos.push(normalizeKey(r));
			}
			return { pos, neg, types, lessThanRegions };
		}
		function itemMatchesPositive(it, token){
			if (token === 'event') return (it.tags||[]).includes('event');
			return includesEffectKey(it.effects, token) || includesName(it.name, token) || includesRegion(it.region, token) || includesSource(it.source, token);
		}
		function itemMatchesNegative(it, token){
			if (token === 'event') return (it.tags||[]).includes('event');
			return includesRegion(it.region, token) || includesSource(it.source, token);
		}
		function effectTokensFromPos(posTokens){
			const out = [];
			for (const t of posTokens){
				if (t === 'event') continue;
				for (const k of ALL_EFFECT_KEYS){ if (k.includes(t)) { out.push(t); break; } }
			}
			return out;
		}

		let ALL_ITEMS = [];
		let ALL_EFFECT_KEYS = new Set();

		function findFirstEffectToken(tokens){
			for (const t of tokens){
				for (const k of ALL_EFFECT_KEYS){ if (k.includes(t)) return t; }
			}
			return null;
		}

		const EQUIPPED = new Map();
		for (const t of ORDERED_TYPES) EQUIPPED.set(t, new Map());

		function toast(msg){
			const el = document.getElementById('toast');
			el.querySelector('.msg').textContent = msg;
			el.style.display = 'block';
			clearTimeout(window.__toastTimer);
			window.__toastTimer = setTimeout(()=>{ el.style.display = 'none'; }, 2000);
		}

		function getEquippedEntry(type, name){
			const perType = EQUIPPED.get(type) || new Map();
			return perType.get(name);
		}
		function getEquippedCountForType(type){
			const perType = EQUIPPED.get(type) || new Map();
			return perType.size;
		}

		function canEquip(it){
			const type = it.type;
			const perType = EQUIPPED.get(type) || new Map();
			if (perType.has(it.name)) return {ok:false,reason:'Already equipped'};
			if (type === 'collection' || type === 'achievement') return {ok:true};
			if (type === 'accessory') {
				const limit = allowAccThird ? 3 : 2;
				if (perType.size >= limit) return {ok:false,reason:`Max ${limit} accessories`};
				return {ok:true};
			}
			if (type === 'retainer') {
				const limit = allowRetThird ? 3 : 2;
				if (perType.size >= limit) return {ok:false,reason:`Max ${limit} retainers`};
				return {ok:true};
			}
			// all other types: only 1
			if (perType.size >= 1) return {ok:false,reason:`Only 1 ${type}`};
			return {ok:true};
		}
		function equip(it){
			const type = it.type;
			const perType = EQUIPPED.get(type) || new Map();
			const check = canEquip(it);
			if (!check.ok){ toast(check.reason); return false; }
			perType.set(it.name, { it });
			EQUIPPED.set(type, perType);
			updateEqCount();
			renderEquipped();
			onQuery();
			return true;
		}
		function unequip(type, name, requireConfirm){
			if (requireConfirm) {
				if (!confirm('Unequip item?')) {
					return;
				}
			}
			const perType = EQUIPPED.get(type) || new Map();
			perType.delete(name);
			EQUIPPED.set(type, perType);
			updateEqCount();
			renderEquipped();
			onQuery();
		}
		function clearAll(){
			for (const t of EQUIPPED.keys()) EQUIPPED.set(t, new Map());
			updateEqCount();
			renderEquipped();
			onQuery();
		}
		function updateEqCount(){
			let total = 0;
			for (const t of EQUIPPED.keys()) total += getEquippedCountForType(t);
			document.getElementById('eqCount').textContent = total;
		}


		// Aggregate effects ranges - combinable skills are summed, uncombinable skills are kept separate

		function aggregateEffectsRanges(){
			const totals = new Map();
			function containsPercentInValue(value){
				if (value == null) return false;
				if (Array.isArray(value)) return value.some(v => containsPercentInValue(v));
				return String(value).includes('%');
			}

			if (combineable.length === 0 || Object.keys(skill_groups).length === 0) {
				return totals;
			}

			const typesToProcess = categorizeMode && currentCategory !== 'all'
				? [currentCategory]
				: Array.from(EQUIPPED.keys());

			for (const type of typesToProcess){
				const perType = EQUIPPED.get(type);
				if (!perType) continue;

				for (const {it} of perType.values()){
					for (const [effKey, effVal] of Object.entries(it.effects||{})){
						const r = rangeFromValue(effVal);

						if (combineable.includes(effKey)) {
							const rec = totals.get(effKey) || { displayKey: effKey, min: 0, max: 0, details: [], percent: false };
							rec.min += r.min;
							rec.max += r.max;
							rec.percent = rec.percent || containsPercentInValue(effVal);
							const valStr = (r.min===r.max) ? `${r.min}` : `${r.min}-${r.max}`;
							rec.details.push(`${it.name}: ${rec.percent ? valStr+"%" : valStr}`);
							totals.set(effKey, rec);
						} else {
							const uniqueKey = effKey + "#" + it.name;
							// Special handling for Loot Hunter effects which are of form "Loot Hunter: <material>"
							let displayKey = effKey;
							let subKey = null;
							if (typeof effKey === 'string' && effKey.startsWith('Loot Hunter:')) {
								displayKey = 'Loot Hunter';
								subKey = effKey.split(':').slice(1).join(':').trim();
							}
							const rec = { displayKey: displayKey, subKey: subKey, origKey: effKey, min: r.min, max: r.max, details: [], percent: false };
							rec.percent = rec.percent || containsPercentInValue(effVal);
							const valStr = (r.min===r.max) ? `${r.min}` : `${r.min}-${r.max}`;
							rec.details.push(`${it.name}: ${rec.percent ? valStr+"%" : valStr}`);
							totals.set(uniqueKey, rec);
						}
					}
				}
			}
			return totals;
		}



		function generateItemStats(item) {
			if (!item.effects || Object.keys(item.effects).length === 0) {
				return '<div class="tooltip-stat">No effects</div>';
			}
			
			let statsHTML = '';
			
			// Check for health first (special case)
			if (item.effects.Health !== undefined) {
				const healthValue = item.effects.Health;
				const healthText = Array.isArray(healthValue) ? healthValue.join(', ') : String(healthValue);
				statsHTML += `<div class="tooltip-stat"><span class="tooltip-stat-name">Health:</span><span class="tooltip-stat-value">${healthText}</span></div>`;
			}
			
			// Process other effects by group
			for (const [groupName, skills] of Object.entries(skill_groups)) {
				if (groupName === 'Heal') {
					// Handle heal group (excluding health which was already handled)
					const healSkills = skills.filter(skill => skill.toLowerCase() !== 'health');
					for (const skill of healSkills) {
						if (item.effects[skill] !== undefined) {
							const value = item.effects[skill];
							const valueText = Array.isArray(value) ? value.join(', ') : String(value);
							statsHTML += `<div class="tooltip-stat"><span class="tooltip-stat-name">${skill}:</span><span class="tooltip-stat-value">${valueText}</span></div>`;
						}
					}
				} else {
					// Handle other groups
					for (const skill of skills) {
						if (item.effects[skill] !== undefined) {
							const value = item.effects[skill];
							const valueText = Array.isArray(value) ? value.join(', ') : String(value);
							statsHTML += `<div class="tooltip-stat"><span class="tooltip-stat-name">${skill}:</span><span class="tooltip-stat-value">${valueText}</span></div>`;
						}
					}
				}
			}
			
			// Add any remaining effects that aren't in skill_groups
			for (const [effectName, value] of Object.entries(item.effects)) {
				if (!Object.values(skill_groups).flat().includes(effectName) && effectName !== 'Health') {
					const valueText = Array.isArray(value) ? value.join(', ') : String(value);
					statsHTML += `<div class="tooltip-stat"><span class="tooltip-stat-name">${effectName}:</span><span class="tooltip-stat-value">${valueText}</span></div>`;
				}
			}
			
			return statsHTML || '<div class="tooltip-stat">No effects</div>';
		}



		function renderAggregatedEffects(){
		  const agg = aggregateEffectsRanges();
		  const container = document.getElementById('aggEffects');
		  container.innerHTML = '';
		  
		  if (combineable.length === 0 || Object.keys(skill_groups).length === 0) {
			container.innerHTML = '<div class="muted">Loading constants...</div>';
			return;
		  }
		  
		  if (agg.size === 0) {
			container.innerHTML = '<div class="muted">No items equipped.</div>';
			return;
		  }

		  const entries = Array.from(agg.entries());
		  
		  // Filter entries based on equipped search query
		  const equippedSearchQuery = document.getElementById('equippedSearch').value.trim().toLowerCase();
		  let filteredEntries = entries;
		  if (equippedSearchQuery) {
			filteredEntries = entries.filter(([, v]) => {
				const displayKey = (v.displayKey || '').toLowerCase();
				const details = v.details.join(' ').toLowerCase();
				return displayKey.includes(equippedSearchQuery) || details.includes(equippedSearchQuery);
			});
		  }
		  
		  if (filteredEntries.length === 0) {
			container.innerHTML = equippedSearchQuery ? '<div class="muted">No equipped effects match your search.</div>' : '<div class="muted">No items equipped.</div>';
			return;
		  }
		  const list = document.createElement('div');
		  list.className = 'agg-list';

		  const healthEntries = filteredEntries.filter(([, v]) => 
			(v.displayKey || '').toLowerCase() === 'health'
		  );
		  if (healthEntries.length > 0) {
		  const combinedHealth = { displayKey: 'Health', min: 0, max: 0, details: [], percent: false };
			for (const [, v] of healthEntries) {
			  combinedHealth.min += v.min;
			  combinedHealth.max += v.max;
			  combinedHealth.percent = combinedHealth.percent || v.percent;
			  combinedHealth.details.push(...v.details);
			}
			
			const row = document.createElement('div');
			row.className = 'agg-effect';

			const head = document.createElement('div');
			head.className = 'agg-head';

			const nameEl = document.createElement('div');
			nameEl.className = 'agg-name';
			nameEl.textContent = combinedHealth.displayKey || '';

			const totalEl = document.createElement('div');
			totalEl.className = 'agg-total';
			const totalVal = (combinedHealth.min === combinedHealth.max) ? `${combinedHealth.min}` : `${combinedHealth.min}-${combinedHealth.max}`;
			totalEl.textContent = combinedHealth.percent ? `${totalVal}%` : totalVal;

			head.appendChild(nameEl);
			head.appendChild(totalEl);
			row.appendChild(head);

			const details = document.createElement('div');
			details.className = 'agg-details muted';
			details.textContent = combinedHealth.details.join(' | ');
			row.appendChild(details);

			list.appendChild(row);
		  }

		  for (const [groupName, skills] of Object.entries(skill_groups)) {
			if (groupName === 'Heal') {
			  const healSkills = skills.filter(skill => skill.toLowerCase() !== 'health');
			  if (healSkills.length === 0) continue;
			  
			  const header = document.createElement('div');
			  header.className = 'agg-group-header';
			  header.textContent = groupName;
			  header.style.fontWeight = 'bold';
			  header.style.marginTop = '10px';
			  header.style.color = '#F4E5B7';
			  list.appendChild(header);

			  const sortedHealSkills = [...healSkills].sort((a, b) => a.localeCompare(b));
			  
			  for (const skill of sortedHealSkills) {
				const groupEntries = filteredEntries.filter(([, v]) =>
				  (v.displayKey || '').toLowerCase() === skill.toLowerCase()
				);
				if (groupEntries.length === 0) continue;

				const combinableEntries = groupEntries.filter(([k]) => !k.includes('#'));
				const uncombinableEntries = groupEntries.filter(([k]) => k.includes('#'));

				if (skill !== 'Weapon Attack') {
				  combinableEntries.sort(([, a], [, b]) => (a.displayKey || '').localeCompare(b.displayKey || ''));
				  uncombinableEntries.sort(([, a], [, b]) => (a.displayKey || '').localeCompare(b.displayKey || ''));
				}

				for (const [key, v] of combinableEntries) {
				  const row = document.createElement('div');
				  row.className = 'agg-effect';

				  const head = document.createElement('div');
				  head.className = 'agg-head';

				  const nameEl = document.createElement('div');
				  nameEl.className = 'agg-name';
				  nameEl.appendChild(document.createTextNode(v.displayKey || ''));

				  const totalEl = document.createElement('div');
				  totalEl.className = 'agg-total';
				  const totalVal = (v.min === v.max) ? `${v.min}` : `${v.min}-${v.max}`;
				  totalEl.textContent = v.percent ? `${totalVal}%` : totalVal;

				  head.appendChild(nameEl);
				  head.appendChild(totalEl);
				  row.appendChild(head);

				  const details = document.createElement('div');
				  details.className = 'agg-details muted';
				  details.textContent = v.details.join(' | ');
				  row.appendChild(details);
				  list.appendChild(row);
				}

				if (uncombinableEntries.length > 0) {
				  if (skill === 'Weapon Attack') {
					const weaponAttackOrder = skill_groups['Weapon Attack'];
					
					for (const effectName of weaponAttackOrder) {
					  const matchingEntries = uncombinableEntries.filter(([, v]) => 
						v.displayKey.toLowerCase() === effectName.toLowerCase()
					  );
					  
					  if (matchingEntries.length === 0) continue;
					  
					  for (const [key, v] of matchingEntries) {
						const row = document.createElement('div');
						row.className = 'agg-effect';

						const head = document.createElement('div');
						head.className = 'agg-head';

						const nameEl = document.createElement('div');
						nameEl.className = 'agg-name';
						nameEl.appendChild(document.createTextNode(v.displayKey || ''));

						const totalEl = document.createElement('div');
						totalEl.className = 'agg-total';
						const totalVal = (v.min === v.max) ? `${v.min}` : `${v.min}-${v.max}`;
						totalEl.textContent = v.percent ? `${totalVal}%` : totalVal;

						head.appendChild(nameEl);
						head.appendChild(totalEl);
						row.appendChild(head);

						const details = document.createElement('div');
						details.className = 'agg-details muted';
						details.textContent = v.details.join(' | ');
						row.appendChild(details);
						list.appendChild(row);
					  }
					}
					} else {
						const uncombinableGroups = new Map();
						
						for (const [key, v] of uncombinableEntries) {
					  const displayKey = v.displayKey;
					  if (!uncombinableGroups.has(displayKey)) {
						uncombinableGroups.set(displayKey, {
						  displayKey: displayKey,
						  min: 0,
						  max: 0,
						  details: [],
						  percent: false,
						  items: []
						});
					  }
					  const group = uncombinableGroups.get(displayKey);
					  group.min += v.min;
					  group.max += v.max;
					  group.percent = group.percent || v.percent;
					  group.items.push(v);
					}

						const sortedUncombinableGroups = Array.from(uncombinableGroups.entries()).sort(([a], [b]) => a.localeCompare(b));
						
						for (const [displayKey, group] of sortedUncombinableGroups) {
					  const row = document.createElement('div');
					  row.className = 'agg-effect';

					  const head = document.createElement('div');
					  head.className = 'agg-head';

					  const nameEl = document.createElement('div');
					  nameEl.className = 'agg-name';
					  
					  const toggle = document.createElement('span');
					  toggle.className = 'agg-toggle';
					  toggle.textContent = '+';
					  toggle.onclick = function() {
						const details = row.querySelector('.agg-details');
						if (details.classList.contains('collapsed')) {
						  details.classList.remove('collapsed');
						  details.classList.add('expanded');
						  toggle.textContent = '-';
						} else {
						  details.classList.remove('expanded');
						  details.classList.add('collapsed');
						  toggle.textContent = '+';
						}
					  };
					  nameEl.appendChild(toggle);
					  nameEl.appendChild(document.createTextNode(`${group.displayKey || ''} (${group.items.length})`));

					  const totalEl = document.createElement('div');
					  totalEl.className = 'agg-total';
					  const totalVal = (group.min === group.max) ? `${group.min}` : `${group.min}-${group.max}`;
					  totalEl.textContent = group.percent ? `${totalVal}%` : totalVal;

					  head.appendChild(nameEl);
					  head.appendChild(totalEl);
					  row.appendChild(head);

											const details = document.createElement('div');
											details.className = 'agg-details collapsed muted';

											// Special nested handling for Loot Hunter: material grouping
											if ((group.displayKey || '').toLowerCase() === 'loot hunter') {
												// Group items by material (subKey)
												const matMap = new Map();
												for (const it of group.items) {
													const mat = it.subKey || (it.origKey || '').split(':').slice(1).join(':').trim() || it.origKey;
													if (!matMap.has(mat)) matMap.set(mat, { min: 0, max: 0, percent: it.percent, items: [] });
													const entry = matMap.get(mat);
													entry.min += it.min;
													entry.max += it.max;
													entry.percent = entry.percent || it.percent;
													entry.items.push(it);
												}

												const sortedMats = Array.from(matMap.entries()).sort((a,b) => a[0].localeCompare(b[0]));
												for (const [mat, matGroup] of sortedMats) {
													const matRow = document.createElement('div');
													matRow.className = 'agg-detail-item nested-material';

													const matToggle = document.createElement('span');
													matToggle.className = 'agg-subtoggle';
													matToggle.textContent = '+';
													matToggle.onclick = function() {
														const matDetails = matRow.querySelector('.mat-details');
														if (!matDetails) return;
														if (matDetails.classList.contains('collapsed')) {
															matDetails.classList.remove('collapsed');
															matDetails.classList.add('expanded');
															matToggle.textContent = '-';
														} else {
															matDetails.classList.remove('expanded');
															matDetails.classList.add('collapsed');
															matToggle.textContent = '+';
														}
													};

													const matName = document.createElement('div');
													matName.className = 'item-name';
													matName.textContent = mat + ` (${matGroup.items.length})`;

													const matVal = document.createElement('div');
													matVal.className = 'item-value';
													const mVal = (matGroup.min === matGroup.max) ? `${matGroup.min}` : `${matGroup.min}-${matGroup.max}`;
													matVal.textContent = matGroup.percent ? `${mVal}%` : mVal;

													matRow.appendChild(matToggle);
													matRow.appendChild(matName);
													matRow.appendChild(matVal);

													// mat details (instances)
													const matDetails = document.createElement('div');
													matDetails.className = 'mat-details collapsed muted';
													const sortedItems = [...matGroup.items].sort((a,b)=> { const avgA=(a.min+a.max)/2; const avgB=(b.min+b.max)/2; return avgB-avgA; });
													for (const item of sortedItems) {
														const itemRow = document.createElement('div');
														itemRow.className = 'agg-detail-item';
														const itemName = document.createElement('div');
														itemName.className = 'item-name';
														itemName.textContent = item.details[0].split(':')[0];
														const itemValue = document.createElement('div');
														itemValue.className = 'item-value';
														const itemRange = (item.min === item.max) ? `${item.min}` : `${item.min}-${item.max}`;
														itemValue.textContent = matGroup.percent ? `${itemRange}%` : itemRange;
														itemRow.appendChild(itemName);
														itemRow.appendChild(itemValue);
														matDetails.appendChild(itemRow);
													}

													details.appendChild(matRow);
													details.appendChild(matDetails);
												}
											} else {
												const sortedItems = [...group.items].sort((a, b) => {
													const avgA = (a.min + a.max) / 2;
													const avgB = (b.min + b.max) / 2;
													return avgB - avgA;
												});
                        
												for (const item of sortedItems) {
													const itemRow = document.createElement('div');
													itemRow.className = 'agg-detail-item';
                          
													const itemName = document.createElement('div');
													itemName.className = 'item-name';
													itemName.textContent = item.details[0].split(':')[0];
                          
													const itemValue = document.createElement('div');
													itemValue.className = 'item-value';
													const itemRange = (item.min === item.max) ? `${item.min}` : `${item.min}-${item.max}`;
													itemValue.textContent = group.percent ? `${itemRange}%` : itemRange;
                          
													itemRow.appendChild(itemName);
													itemRow.appendChild(itemValue);
													details.appendChild(itemRow);
											}
											}

										row.appendChild(details);
										list.appendChild(row);
				  }
				  }
				}
			  }
			} else {
			  const header = document.createElement('div');
			  header.className = 'agg-group-header';
			  header.textContent = groupName;
			  header.style.fontWeight = 'bold';
			  header.style.marginTop = '10px';
			  header.style.color = '#F4E5B7';
			  list.appendChild(header);

			  const sortedSkills = skills.filter(skill => skill.toLowerCase() !== 'health').map(skill => {
				if (skill === 'Weapon Attack') {
				  return skill;
				}
				return skill;
			  }).sort((a, b) => {
				if (a === 'Weapon Attack' || b === 'Weapon Attack') {
				  return 0;
				}
				return a.localeCompare(b);
			  });
			  
			  for (const skill of sortedSkills) {
				if (skill.toLowerCase() === 'health') continue;
				
				const groupEntries = filteredEntries.filter(([, v]) =>
				  (v.displayKey || '').toLowerCase() === skill.toLowerCase()
				);
				if (groupEntries.length === 0) continue;

				const combinableEntries = groupEntries.filter(([k]) => !k.includes('#'));
				const uncombinableEntries = groupEntries.filter(([k]) => k.includes('#'));
				
				if (skill !== 'Weapon Attack') {
				  combinableEntries.sort(([, a], [, b]) => (a.displayKey || '').localeCompare(b.displayKey || ''));
				  uncombinableEntries.sort(([, a], [, b]) => (a.displayKey || '').localeCompare(b.displayKey || ''));
				}

				for (const [key, v] of combinableEntries) {
				  const row = document.createElement('div');
				  row.className = 'agg-effect';

				  const head = document.createElement('div');
				  head.className = 'agg-head';

				  const nameEl = document.createElement('div');
				  nameEl.className = 'agg-name';
				  nameEl.appendChild(document.createTextNode(v.displayKey || ''));

				  const totalEl = document.createElement('div');
				  totalEl.className = 'agg-total';
				  const totalVal = (v.min === v.max) ? `${v.min}` : `${v.min}-${v.max}`;
				  totalEl.textContent = v.percent ? `${totalVal}%` : totalVal;

				  head.appendChild(nameEl);
				  head.appendChild(totalEl);
				  row.appendChild(head);

				  const details = document.createElement('div');
				  details.className = 'agg-details muted';
				  details.textContent = v.details.join(' | ');
				  row.appendChild(details);
				  list.appendChild(row);
				}

				if (uncombinableEntries.length > 0) {
				  const uncombinableGroups = new Map();
				  
				  for (const [key, v] of uncombinableEntries) {
					const displayKey = v.displayKey;
					if (!uncombinableGroups.has(displayKey)) {
					  uncombinableGroups.set(displayKey, {
						displayKey: displayKey,
						min: 0,
						max: 0,
						details: [],
						percent: false,
						items: []
					  });
					}
					const group = uncombinableGroups.get(displayKey);
					group.min += v.min;
					group.max += v.max;
					group.percent = group.percent || v.percent;
					group.items.push(v);
				  }

				  const sortedUncombinableGroups = Array.from(uncombinableGroups.entries()).sort(([a], [b]) => a.localeCompare(b));
				  
				  for (const [displayKey, group] of sortedUncombinableGroups) {
					const row = document.createElement('div');
					row.className = 'agg-effect';

					const head = document.createElement('div');
					head.className = 'agg-head';

					const nameEl = document.createElement('div');
					nameEl.className = 'agg-name';
					
				  const toggle = document.createElement('span');
					toggle.className = 'agg-toggle';
					toggle.textContent = '+';
					toggle.onclick = function() {
					  const details = row.querySelector('.agg-details');
					  if (details.classList.contains('collapsed')) {
						details.classList.remove('collapsed');
						details.classList.add('expanded');
						toggle.textContent = '-';
					  } else {
						details.classList.remove('expanded');
						details.classList.add('collapsed');
						toggle.textContent = '+';
					  }
					};
					nameEl.appendChild(toggle);
					nameEl.appendChild(document.createTextNode(`${group.displayKey || ''} (${group.items.length})`));

					const totalEl = document.createElement('div');
					totalEl.className = 'agg-total';
					const totalVal = (group.min === group.max) ? `${group.min}` : `${group.min}-${group.max}`;
					totalEl.textContent = group.percent ? `${totalVal}%` : totalVal;

					head.appendChild(nameEl);
					head.appendChild(totalEl);
					row.appendChild(head);

				  const details = document.createElement('div');
					details.className = 'agg-details collapsed muted';
					
				  const sortedItems = [...group.items].sort((a, b) => {
					  const avgA = (a.min + a.max) / 2;
					  const avgB = (b.min + b.max) / 2;
						return avgB - avgA;
					});
					
				  for (const item of sortedItems) {
					  const itemRow = document.createElement('div');
					  itemRow.className = 'agg-detail-item';
						
					  const itemName = document.createElement('div');
					  itemName.className = 'item-name';
					  itemName.textContent = item.details[0].split(':')[0];
						
					  const itemValue = document.createElement('div');
					  itemValue.className = 'item-value';
					  const itemRange = (item.min === item.max) ? `${item.min}` : `${item.min}-${item.max}`;
					  itemValue.textContent = group.percent ? `${itemRange}%` : itemRange;
						
					  itemRow.appendChild(itemName);
					  itemRow.appendChild(itemValue);
					  details.appendChild(itemRow);
					}
					
					row.appendChild(details);
					list.appendChild(row);
				  }
				}
			  }
			}
		  }

		  container.appendChild(list);
		}



		function renderMissingTypesBanner(){
			const banner = document.getElementById('missingTypes');
			const listEl = document.getElementById('equippedLists');
			if (listEl.dataset.hidden === '1') { banner.style.display='none'; banner.textContent=''; return; }
			
			if (categorizeMode && currentCategory !== 'all') {
				banner.style.display='none';
				banner.textContent='';
				return;
			}
			
			const parts = [];
			for (const t of ORDERED_TYPES){
				if (t === 'collection' || t === 'achievement' || t === 'accessory' || t === 'retainer') continue;
				const perType = EQUIPPED.get(t) || new Map();
				const missing = Math.max(0, 1 - perType.size);
				if (missing > 0){
					const label = t.charAt(0).toUpperCase()+t.slice(1);
					parts.push(label + (missing===1 ? '' : ` x${missing}`));
				}
			}
			const accLimit = allowAccThird ? 3 : 2;
			const retLimit = allowRetThird ? 3 : 2;
			const accMissing = Math.max(0, accLimit - (EQUIPPED.get('accessory')||new Map()).size);
			if (accMissing>0) parts.push('Accessory' + (accMissing===1?'':` x${accMissing}`));
			const retMissing = Math.max(0, retLimit - (EQUIPPED.get('retainer')||new Map()).size);
			if (retMissing>0) parts.push('Retainer' + (retMissing===1?'':` x${retMissing}`));
			if (parts.length === 0){ banner.style.display='none'; banner.textContent=''; return; }
			banner.textContent = 'Missing types: ' + parts.join(', ');
			banner.style.display = 'block';
		}

		function generateWikiUrl(item) {
			const region = item.region;
			const itemName = item.name.replace(/"/g, '').replace(/\s+/g, '_');
			
			if (item.type === 'hex') {
				return `https://the-bloodlore-chronicles.fandom.com/wiki/Hex_Overhaul#${itemName}`;
			}
			if (item.type === 'achievement') {
				return `https://the-bloodlore-chronicles.fandom.com/wiki/Achievement#${itemName}`;
			}
			if (item.type === 'collection') {
				const itemNameLower = item.name.toLowerCase();
				
				if (itemNameLower.includes('crows hill collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#R1`;
				if (itemNameLower.includes('dark forest collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#R2`;
				if (itemNameLower.includes('underground sewers collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#R3`;
				if (itemNameLower.includes('neo kyoto collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#R4`;
				if (itemNameLower.includes('abandoned industrial complex collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#R5`;
				if (itemNameLower.includes('infernal planes collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#R6`;
				if (itemNameLower.includes('frostlands collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#R7`;
				if (itemNameLower.includes('dust devil desert collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#R8`;
				if (itemNameLower.includes('abyssal depths collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#R9`;
				if (itemNameLower.includes('vangoth castle collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#R10`;
				if (itemNameLower.includes('epic collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#Epic_1`;
				if (itemNameLower.includes('squirrel collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#Squirrel_1`;
				if (itemNameLower.includes('pumpkin fields collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#R1.3`;
				if (itemNameLower.includes('haunted winterland collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#R2.3`;
				if (itemNameLower.includes('dark dimension collection')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#DD`;
				if (itemNameLower.includes('archangel')) return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#AA`;
				
				return `https://the-bloodlore-chronicles.fandom.com/wiki/Treasury#${itemName}`;
			}
			if (item.type === 'emblem') {
				return `https://the-bloodlore-chronicles.fandom.com/wiki/Emblem_Overhaul#${itemName}`;
			}
			if (item.type === 'key') {
				return `https://the-bloodlore-chronicles.fandom.com/wiki/Key_Overhaul#${itemName}`;
			}
			if (item.type === 'bait') {
				return `https://the-bloodlore-chronicles.fandom.com/wiki/Bait_Overhaul#${itemName}`;
			}
			
			if (region === 'PS2024') {
				return `https://the-bloodlore-chronicles.fandom.com/wiki/2023-2024_Premium_Shop/Giveaways#${itemName}`;
			}
			if (region === 'PS2025') {
				return `https://the-bloodlore-chronicles.fandom.com/wiki/2025_Premium_Shop/Giveaways#${itemName}`;
			}
			if (region === 'RDD') {
				return `https://the-bloodlore-chronicles.fandom.com/wiki/DD_Equipment_Stat#${itemName}`;
			}
			if (region === 'RAA') {
				return `https://the-bloodlore-chronicles.fandom.com/wiki/AA_Equipment_Stat#${itemName}`;
			}
			if (region === 'R01.3') {
				return `https://the-bloodlore-chronicles.fandom.com/wiki/R1.3_Equipment_Stat#${itemName}`;
			}
			if (region === 'R02.3') {
				return `https://the-bloodlore-chronicles.fandom.com/wiki/R2.3_Equipment_Stat#${itemName}`;
			}
			
			if (region.match(/^R\d+$/)) {
				const zoneNumber = region.substring(1); // Remove the 'R' prefix
				const zoneWithoutZero = zoneNumber.replace(/^0+/, ''); // Remove leading zeros
				return `https://the-bloodlore-chronicles.fandom.com/wiki/R${zoneWithoutZero}_Equipment#${itemName}`;
			}
			
			return `https://the-bloodlore-chronicles.fandom.com/wiki/${region}_Equipment#${itemName}`;
		}

		function renderEquipped(){
			const container = document.getElementById('equippedLists');
			if (container.dataset.hidden === '1'){
				document.getElementById('aggEffects').innerHTML = '';
				renderAggregatedEffects();
				document.getElementById('missingTypes').style.display='none';
				return;
			}
			container.innerHTML = '';
			
			// Create the equipment grid
			const gridContainer = document.createElement('div');
			gridContainer.className = 'equipment-grid';
			
			// Define the grid layout
			const gridLayout = [
				['coin', 'head', 'bait', 'hex'],
				['weapon', 'chest', 'hand'],
				['power', 'feet', 'emblem'],
				['coffin', 'acc1', 'acc2', 'acc3'],
				['mount', 'ret1', 'ret2', 'ret3']
			];
			
			// Create grid rows
			for (let rowIndex = 0; rowIndex < gridLayout.length; rowIndex++) {
				const row = document.createElement('div');
				row.className = 'equipment-row';
				
				for (let colIndex = 0; colIndex < gridLayout[rowIndex].length; colIndex++) {
					const slotType = gridLayout[rowIndex][colIndex];
					const slot = document.createElement('div');
					slot.className = 'equipment-slot';
					slot.className += ` slot-${slotType}`;
					
					// Handle accessory slots (acc1, acc2, acc3)
					let actualType = slotType;
					if (slotType.startsWith('acc')) {
						const accNum = parseInt(slotType.slice(3));
						if (accNum === 3 && !allowAccThird) {
							slot.className += ' disabled-slot';
							slot.innerHTML = '<div class="slot-label">3rd acc.</div><div class="slot-disabled">Disabled</div>';
						} else {
							actualType = 'accessory';
						}
					}
					
					// Handle retainer slots (ret1, ret2, ret3)
					if (slotType.startsWith('ret')) {
						const retNum = parseInt(slotType.slice(3));
						if (retNum === 3 && !allowRetThird) {
							slot.className += ' disabled-slot';
							slot.innerHTML = '<div class="slot-label">3rd ret.</div><div class="slot-disabled">Disabled</div>';
						} else {
							actualType = 'retainer';
						}
					}
					
					// Find equipped item for this slot
					const perType = EQUIPPED.get(actualType);
					let equippedItem = null;
					
					if (perType && perType.size > 0) {
						// For accessories and retainers, we need to handle multiple slots
						if (actualType === 'accessory' && slotType.startsWith('acc')) {
							const accNum = parseInt(slotType.slice(3));
							const items = Array.from(perType.values());
							if (items[accNum - 1]) {
								equippedItem = items[accNum - 1].it;
							}
						} else if (actualType === 'retainer' && slotType.startsWith('ret')) {
							const retNum = parseInt(slotType.slice(3));
							const items = Array.from(perType.values());
							if (items[retNum - 1]) {
								equippedItem = items[retNum - 1].it;
							}
						} else {
							// Single slot types
							const items = Array.from(perType.values());
							if (items[0]) {
								equippedItem = items[0].it;
							}
						}
					}
					
					// Always show slot type at the top
					const slotLabel = slotType === 'acc1' ? '1st acc.' : 
									slotType === 'acc2' ? '2nd acc.' : 
									slotType === 'acc3' ? '3rd acc.' :
									slotType === 'ret1' ? '1st ret.' : 
									slotType === 'ret2' ? '2nd ret.' : 
									slotType === 'ret3' ? '3rd ret.' :
									slotType.charAt(0).toUpperCase() + slotType.slice(1);
					
					if (equippedItem) {
						// Item is equipped
						slot.className += ' equipped-slot';
						slot.innerHTML = `
							<div class="slot-label">${slotLabel}</div>
							<div class="item-name">${equippedItem.name}</div>
							<div class="item-region">[${equippedItem.region}]</div>
							<button class="remove-btn" data-type="${actualType}" data-name="${equippedItem.name}">Ã—</button>
							<div class="equipment-tooltip">
								<div class="tooltip-title">${equippedItem.name}</div>
								<div class="tooltip-stats">
									${generateItemStats(equippedItem)}
								</div>
							</div>
						`;
						
						// Add event listener to the remove button
						const removeBtn = slot.querySelector('.remove-btn');
						removeBtn.addEventListener('click', (e) => {
							e.stopPropagation(); // Prevent event bubbling
							unequip(actualType, equippedItem.name, true);
						});
					} else {
						// Empty slot
						slot.innerHTML = `
							<div class="slot-label">${slotLabel}</div>
							<div class="slot-empty">Empty</div>
						`;
					}
					
					row.appendChild(slot);
				}
				
				gridContainer.appendChild(row);
			}
			
			container.appendChild(gridContainer);
			renderAggregatedEffects();
			renderMissingTypesBanner();
		}

		function render(items, query){
			const container = document.getElementById('results');
			container.innerHTML = '';
			const {pos, neg, types, lessThanRegions} = parseQuery(query);
			if (pos.length === 0 && neg.length === 0 && types.length===0 && lessThanRegions.length===0){ container.innerHTML = '<div class="muted">Type terms separated by commasâ€¦ Use -term to exclude by region/source or -event to exclude events. Use !type to filter by item type.</div>'; return; }

			const filtered = items.filter(it => (
				(types.length===0 || types.includes(it.type)) &&
				(pos.length===0 || pos.every(tok => itemMatchesPositive(it, tok))) &&
				(neg.length===0 || !neg.some(tok => itemMatchesNegative(it, tok))) &&
				(lessThanRegions.length===0 || lessThanRegions.every(region => isRegionLessThan(it.region, region)))
			));
			const groups = groupByTypeOrdered(filtered);
			const effectTokens = effectTokensFromPos(pos);
			const firstEffect = findFirstEffectToken(effectTokens);
			const secondEffect = effectTokens.length>1 ? findFirstEffectToken(effectTokens.slice(1)) : null;

			let any = false;
			for (const type of ORDERED_TYPES.concat(Array.from(groups.keys()).filter(k=>!ORDERED_TYPES.includes(k)))){
				const list = groups.get(type);
				if (!list || list.length === 0) continue;
				any = true;
				const withScore = list.map(it => ({
					it,
					primary: maxNumericAcrossMatched(it.effects, firstEffect),
					secondary: maxNumericAcrossMatched(it.effects, secondEffect),
					negAny: anyNegativeForEffects(it.effects, effectTokens),
					display: collectEffectDisplayAll(it.effects, effectTokens)
				})).sort((a,b)=> (b.primary - a.primary) || (b.secondary - a.secondary));

				const sec = document.createElement('div');
				sec.className = 'section';
				const title = document.createElement('h2');
				title.textContent = type.charAt(0).toUpperCase() + type.slice(1) + ` (${withScore.length})`;
				sec.appendChild(title);

				for (const row of withScore){
					const div = document.createElement('div');
					div.className = 'item';
					const perType = EQUIPPED.get(row.it.type) || new Map();
					const isEquipped = perType.has(row.it.name);
					if (isEquipped) div.classList.add('equipped');
					if (row.negAny) div.classList.add('neg-item');
					div.onclick = ()=>{
						if (isEquipped) unequip(row.it.type, row.it.name, false); else equip(row.it);
					};
					const main = document.createElement('div');
					const srcTxt = formatSource(row.it.source);
					const srcSpan = srcTxt ? ` <span class=\"meta\">src: ${srcTxt}</span>` : '';
					const wikiLink = generateWikiUrl(row.it);
					const wikiSpan = wikiLink ? ` <a href="${wikiLink}" target="_blank" class="meta">Wiki</a>` : '';
					main.innerHTML = `<strong>${row.it.name}</strong> <span class=\"meta\">[${row.it.region}]</span>${srcSpan}${wikiSpan}<div class=\"muted\">${row.display}</div>`;
					div.appendChild(main);
					sec.appendChild(div);
				}
				container.appendChild(sec);
			}

			if (!any){ container.innerHTML = '<div class=\"muted\">No matches.</div>'; }
		}

		function onQuery(){ 
			const query = document.getElementById('q').value;
			if (categorizeMode) {
				const categoryTabs = document.getElementById('categoryTabs');
				const equippedCategoryTabs = document.getElementById('equippedCategoryTabs');
				const browseView = document.getElementById('browseView');
				const equippedView = document.getElementById('equippedView');
				
				if (browseView.style.display !== 'none') {
					categoryTabs.style.display = 'block';
					renderCategoryTabs();
				}
				if (equippedView.style.display !== 'none') {
					equippedCategoryTabs.style.display = 'block';
					renderEquippedCategoryTabs();
				}
				renderCategories();
			} else {
				document.getElementById('categoryTabs').style.display = 'none';
				document.getElementById('equippedCategoryTabs').style.display = 'none';
				render(ALL_ITEMS, query);
			}
		}

		function onEquippedSearch() {
			renderAggregatedEffects();
		}

		function renderCategories() {
			const container = document.getElementById('results');
			container.innerHTML = '';
			const query = document.getElementById('q').value;
			
			let itemsToShow = ALL_ITEMS;
			let effectTokens = [];
			if (query.trim()) {
				const {pos, neg, types, lessThanRegions} = parseQuery(query);
				itemsToShow = ALL_ITEMS.filter(it => (
					(types.length===0 || types.includes(it.type)) &&
					(pos.length===0 || pos.every(tok => itemMatchesPositive(it, tok))) &&
					(neg.length===0 || !neg.some(tok => itemMatchesNegative(it, tok))) &&
					(lessThanRegions.length===0 || lessThanRegions.every(region => isRegionLessThan(it.region, region)))
				));
				effectTokens = effectTokensFromPos(pos);
			}
			
			if (currentCategory === 'all') {
				const groups = groupByTypeOrdered(itemsToShow);
				let any = false;
				for (const type of ORDERED_TYPES.concat(Array.from(groups.keys()).filter(k=>!ORDERED_TYPES.includes(k)))){
					const list = groups.get(type);
					if (!list || list.length === 0) continue;
					any = true;
					const sec = document.createElement('div');
					sec.className = 'section';
					const title = document.createElement('h2');
					title.textContent = type.charAt(0).toUpperCase() + type.slice(1) + ` (${list.length})`;
					sec.appendChild(title);

				let sortedList = list;
					if (effectTokens.length > 0) {
						const firstEffect = findFirstEffectToken(effectTokens);
						const secondEffect = effectTokens.length > 1 ? findFirstEffectToken(effectTokens.slice(1)) : null;
						
						sortedList = list.map(it => ({
							it,
							primary: maxNumericAcrossMatched(it.effects, firstEffect),
							secondary: maxNumericAcrossMatched(it.effects, secondEffect),
							negAny: anyNegativeForEffects(it.effects, effectTokens)
						})).sort((a,b)=> (b.primary - a.primary) || (b.secondary - a.secondary));
					}

				for (const itemData of sortedList){
					const item = itemData.it || itemData;
					const div = document.createElement('div');
						div.className = 'item';
						const perType = EQUIPPED.get(item.type) || new Map();
						const isEquipped = perType.has(item.name);
						if (isEquipped) div.classList.add('equipped');
						if (itemData.negAny) div.classList.add('neg-item');
						div.onclick = ()=>{
							if (isEquipped) unequip(item.type, item.name, false); else equip(item);
						};
						const main = document.createElement('div');
						const srcTxt = formatSource(item.source);
						const srcSpan = srcTxt ? ` <span class="meta">src: ${srcTxt}</span>` : '';
						const wikiLink = generateWikiUrl(item);
						const wikiSpan = wikiLink ? ` <a href="${wikiLink}" target="_blank" class="meta">Wiki</a>` : '';
						const effectsDisplay = `<div class="muted">${collectEffectDisplayAll(item.effects, effectTokens)}</div>`;
						main.innerHTML = `<strong>${item.name}</strong> <span class="meta">[${item.region}]</span>${srcSpan}${wikiSpan}${effectsDisplay}`;
						div.appendChild(main);
						sec.appendChild(div);
					}
					container.appendChild(sec);
				}
				if (!any){ container.innerHTML = '<div class="muted">No items found.</div>'; }
			} else {
				const filtered = itemsToShow.filter(item => item.type === currentCategory);
				if (filtered.length === 0) {
					container.innerHTML = '<div class="muted">No items in this category.</div>';
					return;
				}
				
				let sortedFiltered = filtered;
				if (effectTokens.length > 0) {
					const firstEffect = findFirstEffectToken(effectTokens);
					const secondEffect = effectTokens.length > 1 ? findFirstEffectToken(effectTokens.slice(1)) : null;
					
					sortedFiltered = filtered.map(it => ({
						it,
						primary: maxNumericAcrossMatched(it.effects, firstEffect),
						secondary: maxNumericAcrossMatched(it.effects, secondEffect),
						negAny: anyNegativeForEffects(it.effects, effectTokens)
					})).sort((a,b)=> (b.primary - a.primary) || (b.secondary - a.secondary));
				}
				
				const sec = document.createElement('div');
				sec.className = 'section';
				const title = document.createElement('h2');
				title.textContent = currentCategory.charAt(0).toUpperCase() + currentCategory.slice(1) + ` (${filtered.length})`;
				sec.appendChild(title);

				for (const itemData of sortedFiltered){
					const item = itemData.it || itemData;
					const div = document.createElement('div');
					div.className = 'item';
					const perType = EQUIPPED.get(item.type) || new Map();
					const isEquipped = perType.has(item.name);
					if (isEquipped) div.classList.add('equipped');
					if (itemData.negAny) div.classList.add('neg-item');
					div.onclick = ()=>{
						if (isEquipped) unequip(item.type, item.name, false); else equip(item);
					};
					const main = document.createElement('div');
					const srcTxt = formatSource(item.source);
					const srcSpan = srcTxt ? ` <span class="meta">src: ${srcTxt}</span>` : '';
					const wikiLink = generateWikiUrl(item);
					const wikiSpan = wikiLink ? ` <a href="${wikiLink}" target="_blank" class="meta">Wiki</a>` : '';
					const effectsDisplay = `<div class="muted">${collectEffectDisplayAll(item.effects, effectTokens)}</div>`;
					main.innerHTML = `<strong>${item.name}</strong> <span class="meta">[${item.region}]</span>${srcSpan}${wikiSpan}${effectsDisplay}`;
					div.appendChild(main);
					sec.appendChild(div);
				}
				container.appendChild(sec);
			}
		}

		function renderCategoryTabs() {
			const container = document.querySelector('.category-tabs');
			container.innerHTML = '';
			
			const query = document.getElementById('q').value;
			let itemsToCount = ALL_ITEMS;
			if (query.trim()) {
				const {pos, neg, types, lessThanRegions} = parseQuery(query);
				itemsToCount = ALL_ITEMS.filter(it => (
					(types.length===0 || types.includes(it.type)) &&
					(pos.length===0 || pos.every(tok => itemMatchesPositive(it, tok))) &&
					(neg.length===0 || !neg.some(tok => itemMatchesNegative(it, tok))) &&
					(lessThanRegions.length===0 || lessThanRegions.every(region => isRegionLessThan(it.region, region)))
				));
			}
			
			const typeCounts = new Map();
			for (const item of itemsToCount) {
				const count = typeCounts.get(item.type) || 0;
				typeCounts.set(item.type, count + 1);
			}
			
			const allTab = document.createElement('div');
			allTab.className = 'category-tab' + (currentCategory === 'all' ? ' active' : '');
			allTab.textContent = `All (${itemsToCount.length})`;
			allTab.onclick = () => {
				currentCategory = 'all';
				updateCategoryTabs();
				renderCategories();
			};
			container.appendChild(allTab);
			
			for (const type of ORDERED_TYPES) {
				const tab = document.createElement('div');
				tab.className = 'category-tab' + (currentCategory === type ? ' active' : '');
				const count = typeCounts.get(type) || 0;
				tab.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} (${count})`;
				tab.onclick = () => {
					currentCategory = type;
					updateCategoryTabs();
					renderCategories();
				};
				container.appendChild(tab);
			}
		}

		function updateCategoryTabs() {
			const tabs = document.querySelectorAll('.category-tabs .category-tab');
			tabs.forEach(tab => {
				tab.classList.remove('active');
			});
			
			const activeTab = Array.from(tabs).find(tab => {
				if (currentCategory === 'all') {
					return tab.textContent.startsWith('All');
				} else {
					return tab.textContent.startsWith(currentCategory.charAt(0).toUpperCase() + currentCategory.slice(1));
				}
			});
			
			if (activeTab) {
				activeTab.classList.add('active');
			}
		}

		function renderEquippedCategoryTabs() {
			const container = document.querySelector('#equippedCategoryTabs .category-tabs');
			container.innerHTML = '';
			
			const allTab = document.createElement('div');
			allTab.className = 'category-tab' + (currentCategory === 'all' ? ' active' : '');
			allTab.textContent = 'All';
			allTab.onclick = () => {
				currentCategory = 'all';
				updateEquippedCategoryTabs();
				renderEquipped();
			};
			container.appendChild(allTab);
			
			for (const type of ORDERED_TYPES) {
				const tab = document.createElement('div');
				tab.className = 'category-tab' + (currentCategory === type ? ' active' : '');
				tab.textContent = type.charAt(0).toUpperCase() + type.slice(1);
				tab.onclick = () => {
					currentCategory = type;
					updateEquippedCategoryTabs();
					renderEquipped();
				};
				container.appendChild(tab);
			}
		}

		function updateEquippedCategoryTabs() {
			const tabs = document.querySelectorAll('#equippedCategoryTabs .category-tab');
			tabs.forEach(tab => {
				tab.classList.remove('active');
			});
			
			const activeTab = Array.from(tabs).find(tab => {
				if (currentCategory === 'all') {
					return tab.textContent.startsWith('All');
				} else {
					return tab.textContent.startsWith(currentCategory.charAt(0).toUpperCase() + currentCategory.slice(1));
				}
			});
			
			if (activeTab) {
				activeTab.classList.add('active');
			}
		}

		function getSavedBuilds(){
			try { return JSON.parse(localStorage.getItem(BUILDS_KEY) || '[]'); } catch(e){ return []; }
		}
		function setSavedBuilds(list){ localStorage.setItem(BUILDS_KEY, JSON.stringify(list)); }
		function snapshotCurrentBuild(){
			const items = [];
			for (const type of ORDERED_TYPES){
				const perType = EQUIPPED.get(type) || new Map();
				for (const {it} of perType.values()){
					items.push({ region: it.region, type: it.type, name: it.name, qty: 1 });
				}
			}
			return items;
		}
		function findItem(region, type, name){
			return ALL_ITEMS.find(i => i.region===region && i.type===type && i.name===name);
		}
		function loadBuildById(id){
			const list = getSavedBuilds();
			const build = list.find(b => b.id===id);
			if (!build) { toast('Build not found'); return; }
			clearAll();
			const typeToEntries = new Map();
			for (const entry of build.items){
				if (!typeToEntries.has(entry.type)) typeToEntries.set(entry.type, []);
				typeToEntries.get(entry.type).push(entry);
			}
			for (const type of ORDERED_TYPES){
				const entries = typeToEntries.get(type) || [];
				if (entries.length===0) continue;
				if (type === 'accessory'){
					const limit = allowAccThird ? 3 : 2;
					let added = 0;
					const seen = new Set();
					for (const e of entries) {
						if (added >= limit) break;
						if (seen.has(e.name)) continue;
						const it = findItem(e.region, type, e.name);
						if (!it) continue;
						equip(it);
						seen.add(e.name);
						added++;
					}
				} else if (type === 'retainer'){
					const limit = allowRetThird ? 3 : 2;
					let added = 0;
					const seen = new Set();
					for (const e of entries) {
						if (added >= limit) break;
						if (seen.has(e.name)) continue;
						const it = findItem(e.region, type, e.name);
						if (!it) continue;
						equip(it);
						seen.add(e.name);
						added++;
					}
				} else if (type === 'collection' || type === 'achievement'){
					const seen = new Set();
					for (const e of entries) {
						if (seen.has(e.name)) continue;
						const it = findItem(e.region, type, e.name);
						if (!it) continue;
						equip(it);
						seen.add(e.name);
					}
				} else {
					let added = 0;
					const seen = new Set();
					for (const e of entries) {
						if (added >= 1) break;
						if (seen.has(e.name)) continue;
						const it = findItem(e.region, type, e.name);
						if (!it) continue;
						equip(it);
						seen.add(e.name);
						added++;
					}
				}
			}
			toast('Build loaded');
		}
		function deleteBuildById(id){
			const list = getSavedBuilds();
			const idx = list.findIndex(b => b.id===id);
			if (idx>=0){ list.splice(idx,1); setSavedBuilds(list); renderSavedBuilds(); }
		}
		function renderSavedBuilds(){
			const container = document.getElementById('savedBuilds');
			container.innerHTML = '';
			const list = getSavedBuilds();
			for (const b of list){
				const btn = document.createElement('div'); btn.className='build-btn';
				const name = document.createElement('span'); name.className='build-name'; name.textContent = b.name || 'Unnamed';
				const del = document.createElement('button'); del.className='build-del'; del.textContent='X';
				del.onclick=(e)=>{ e.stopPropagation(); if (confirm(`Delete build \"${b.name}\"?`)) deleteBuildById(b.id); };
				btn.onclick=()=>loadBuildById(b.id);
				btn.appendChild(name); btn.appendChild(del);
				container.appendChild(btn);
			}
		}
		function saveCurrentBuild(){
			const name = prompt('Name this build:', 'My Build');
			if (name===null) return;
			const items = snapshotCurrentBuild();
			const list = getSavedBuilds();
			const id = Date.now() + '_' + Math.random().toString(36).slice(2,7);
			list.push({ id, name, items });
			setSavedBuilds(list);
			renderSavedBuilds();
			toast('Build saved');
		}

		function onEquipTabShown(){
			const listEl = document.getElementById('equippedLists');
			listEl.style.display = 'none';
			listEl.dataset.hidden = '1';
			document.getElementById('toggleEqVis').textContent = 'Show equipped items';
			document.getElementById('controls').style.display = 'none';
			const categoryTabs = document.getElementById('categoryTabs');
			const equippedCategoryTabs = document.getElementById('equippedCategoryTabs');
			categoryTabs.style.display = 'none';
			if (categorizeMode) {
				equippedCategoryTabs.style.display = 'block';
				renderEquippedCategoryTabs();
			} else {
				equippedCategoryTabs.style.display = 'none';
			}
			renderAggregatedEffects();
			renderSavedBuilds();
			document.getElementById('missingTypes').style.display='none';
		}

		function onBrowseTabShown(){
			document.getElementById('controls').style.display = 'flex';
			const categoryTabs = document.getElementById('categoryTabs');
			if (categorizeMode) {
				categoryTabs.style.display = 'block';
				renderCategoryTabs();
			} else {
				categoryTabs.style.display = 'none';
			}
			onQuery();
		}

		function initEvents(){
			document.getElementById('q').addEventListener('input', onQuery);
			document.getElementById('equippedSearch').addEventListener('input', onEquippedSearch);
			document.getElementById('fileInput').addEventListener('change', async (ev)=>{
				const file = ev.target.files && ev.target.files[0];
				if (!file) return;
				const text = await file.text();
				localStorage.setItem(CACHE_KEY, text);
				const json = JSON.parse(text);
				ALL_ITEMS = flatten(json);
				ALL_EFFECT_KEYS = new Set();
				for (const it of ALL_ITEMS) {
					for (const k of Object.keys(it.effects)) ALL_EFFECT_KEYS.add(normalizeKey(k));
				}
				document.getElementById('status').textContent = `Loaded ${ALL_ITEMS.length} items.`;
				document.getElementById('q').focus();
				onQuery();
			});
			
			document.getElementById('constantsFileInput').addEventListener('change', async (ev)=>{
				const file = ev.target.files && ev.target.files[0];
				if (!file) return;
				try {
					const text = await file.text();
					const constants = JSON.parse(text);
					skill_groups = constants.skill_groups;
					combineable = constants.combineable;
					type_map = constants.type_map;
					
					document.getElementById('constantsFallback').style.display = 'none';
					renderAggregatedEffects();
				} catch (error) {
					console.error('Failed to parse constants file:', error);
					alert('Failed to load constants file. Please check the file format.');
				}
			});

			document.getElementById('tabBrowse').addEventListener('click', ()=>{
				// Save equipped search text
				equippedSearchText = document.getElementById('equippedSearch').value;
				
				document.getElementById('tabBrowse').classList.add('active');
				document.getElementById('tabEquipped').classList.remove('active');
				document.getElementById('browseView').style.display='block';
				document.getElementById('equippedView').style.display='none';
				document.getElementById('equippedControls').style.display='none';
				
				// Restore browse search text
				document.getElementById('q').value = browseSearchText;
				onBrowseTabShown();
			});
			document.getElementById('tabEquipped').addEventListener('click', ()=>{
				// Save browse search text
				browseSearchText = document.getElementById('q').value;
				
				document.getElementById('tabEquipped').classList.add('active');
				document.getElementById('tabBrowse').classList.remove('active');
				document.getElementById('browseView').style.display='none';
				document.getElementById('equippedView').style.display='block';
				document.getElementById('equippedControls').style.display='flex';
				
				// Restore equipped search text
				document.getElementById('equippedSearch').value = equippedSearchText;
				onEquipTabShown();
			});
			document.getElementById('clearAll').addEventListener('click', clearAll);
			document.getElementById('toggleEqVis').addEventListener('click', ()=>{
				const listEl = document.getElementById('equippedLists');
				if (listEl.style.display === 'none'){
					listEl.style.display = 'block';
					listEl.dataset.hidden = '0';
					document.getElementById('toggleEqVis').textContent = 'Hide equipped items';
					renderEquipped();
				} else {
					listEl.style.display = 'none';
					listEl.dataset.hidden = '1';
					document.getElementById('toggleEqVis').textContent = 'Show equipped items';
					renderAggregatedEffects();
					document.getElementById('missingTypes').style.display='none';
				}
			});
			document.getElementById('saveBuild').addEventListener('click', saveCurrentBuild);
			document.getElementById('helpBtn').addEventListener('click', ()=>{
				const p = document.getElementById('helpPanel');
				p.style.display = p.style.display==='none' ? 'block' : 'none';
			});
			document.getElementById('helpClose').addEventListener('click', ()=>{
				document.getElementById('helpPanel').style.display = 'none';
			});
			const themeBtn = document.getElementById('themeToggle');
			function refreshThemeButtonLabel(){
				const explicit = document.documentElement.getAttribute('data-theme');
				if (explicit === 'light') { themeBtn.textContent = 'Dark Mode'; return; }
				if (explicit === 'dark') { themeBtn.textContent = 'Light Mode'; return; }
				const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
				themeBtn.textContent = prefersLight ? 'Dark Mode' : 'Light Mode';
			}
			refreshThemeButtonLabel();
			themeBtn.addEventListener('click', ()=>{
				const current = document.documentElement.getAttribute('data-theme');
				let next;
				if (current === 'light') next = 'dark'; else if (current === 'dark') next = 'light'; else {
					// No explicit theme; infer and flip
					const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
					next = prefersLight ? 'dark' : 'light';
				}
				document.documentElement.setAttribute('data-theme', next);
				try { localStorage.setItem(THEME_KEY, next); } catch(e) {}
				refreshThemeButtonLabel();
			});
			document.getElementById('toggleAcc3').addEventListener('change', (e)=>{
				allowAccThird = e.target.checked; 
				saveSettings();
				renderEquipped(); 
				onQuery();
			});
			document.getElementById('toggleRet3').addEventListener('change', (e)=>{
				allowRetThird = e.target.checked; 
				saveSettings();
				renderEquipped(); 
				onQuery();
			});
			document.getElementById('toggleCategorize').addEventListener('change', (e)=>{
				categorizeMode = e.target.checked;
				saveSettings();
				const categoryTabs = document.getElementById('categoryTabs');
				const equippedCategoryTabs = document.getElementById('equippedCategoryTabs');
				if (categorizeMode) {
					categoryTabs.style.display = 'block';
					equippedCategoryTabs.style.display = 'block';
					renderCategoryTabs();
					renderEquippedCategoryTabs();
					onQuery();
				} else {
					categoryTabs.style.display = 'none';
					equippedCategoryTabs.style.display = 'none';
					onQuery();
				}
			});
		}

		async function tryFetchJson(){
			const status = document.getElementById('status');
			try {
				const res = await fetch('item_glossary.json?v=' + Date.now(), { cache: 'no-store' });
				if (!res.ok) throw new Error('HTTP '+res.status);
				const text = await res.text();
				localStorage.setItem(CACHE_KEY, text);
				const data = JSON.parse(text);
				ALL_ITEMS = flatten(data);
				ALL_EFFECT_KEYS = new Set();
				for (const it of ALL_ITEMS) {
					for (const k of Object.keys(it.effects)) ALL_EFFECT_KEYS.add(normalizeKey(k));
				}
				status.textContent = `Loaded ${ALL_ITEMS.length} items.`;
				document.getElementById('fallback').style.display = 'none';
				onQuery();
				renderAggregatedEffects();
				return;
			} catch (e) {}
			try {
				const cached = localStorage.getItem(CACHE_KEY);
				if (cached) {
					const data = JSON.parse(cached);
					ALL_ITEMS = flatten(data);
					ALL_EFFECT_KEYS = new Set();
					for (const it of ALL_ITEMS) {
						for (const k of Object.keys(it.effects)) ALL_EFFECT_KEYS.add(normalizeKey(k));
					}
					document.getElementById('status').textContent = `Loaded ${ALL_ITEMS.length} items (from cache).`;
					document.getElementById('fallback').style.display = 'inline';
					onQuery();
					renderAggregatedEffects();
					return;
				}
			} catch (e) {}
			document.getElementById('status').textContent = 'Could not fetch item_glossary.json. Use file picker.';
			document.getElementById('fallback').style.display = 'inline';
		}

		loadSettings();
		initEvents();
		loadConstants().then(() => {
			tryFetchJson();
		});
	})();
	</script>
</body>
</html>

